<body bgcolor=black>
<center><canvas id=canvas width=800 height=800></canvas>
<script src=webgl.js></script>
<script>

/********************************************

You can have fun with it, creating cool
movements of objects around each other.

*********************************************/

function Scene() {

   let NS = 100;  // max number of spheres
   let NL = 3;

   this.vertexShader = `\
   #version 300 es
   in  vec3 aPos;
   out vec3 vPos;
   void main() {
      gl_Position = vec4(aPos, 1.);
      vPos = aPos;
   }`;

   this.fragmentShader = `\
   #version 300 es
   precision highp float;

   uniform float uTime;
   uniform vec3 uViewPoint;
   uniform int uSN;

   uniform vec4 uS[`+NS+`];
   uniform vec3 uSC[`+NS+`];
   uniform vec3 uL[`+NL+`], uLC[`+NL+`];

   in  vec3 vPos;
   out vec4 fragColor;

   vec2 raySphere(vec3 V, vec3 W, vec4 S) {
      V -= S.xyz;
      float b = dot(V, W);
      float d = b * b - dot(V, V) + S.w * S.w;
      if (d < 0.)
         return vec2(1001.,1000.);
      return vec2(-b - sqrt(d), -b + sqrt(d));
   }

   bool inShadow(vec3 P, vec3 L) {
      for (int i = 0 ; i < uSN ; i++) {
         vec2 tt = raySphere(P, L, uS[i]);
         if (tt.x < tt.y && tt.x > 0.)
            return true;
      }
      return false;
   }

   float inShadowSoft(vec3 P, vec3 L) {
      float minDist = 10000.0;
      for (int i = 0; i < uSN; i++) {
         vec2 tt = raySphere(P, L, uS[i]);
         if (tt.x < tt.y && tt.x > 0.) {
            minDist = min(minDist, tt.x);
         }
      }
      return smoothstep(0.0, 0.3, minDist); 
   }

   vec3 shadeSphere(vec4 S, vec3 P, vec3 C) {
      vec3 N = (P - S.xyz) / S.w;

      vec3 shade = vec3(.1);

      shade *= .5 + .5 * sin(20. * N.y);

      // for (int l = 0 ; l < `+NL+` ; l++){
      //    float shadow = inShadowSoft(P, uL[l]);
      //    shade += uLC[l] * max(0., dot(N, uL[l])) * (1.0 - shadow);
      // }

      for (int l = 0 ; l < `+NL+` ; l++)
         if (! inShadow(P, uL[l]))
            shade += uLC[l] * max(0., dot(N, uL[l]));

      return C * shade;
   }

   void main() {
      vec4 F = vec4(0.);
      vec3 V = uViewPoint;
      vec3 W = normalize(vPos-V);
      float t = 100.;

      for (int i = 0 ; i < uSN ; i++) {
         vec2 tt = raySphere(V, W, uS[i]);
         if (tt.x < tt.y && tt.x > 0. && tt.x < t) {
            t = tt.x;
      vec3 P = V + t * W;
            F = vec4(shadeSphere(uS[i],P,uSC[i]),1.);
         }
      }

      fragColor = vec4(sqrt(F.rgb), F.a);
   }`;

   let startTime = Date.now()/1000;

   let normalize = v => {
      let s = Math.sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]);
      return [ v[0]/s, v[1]/s, v[2]/s ];
   }

   this.gravity = -9.8; 
   this.bounce = 0.7;   // bounce factor
   this.minRadius = 0.2;  
   this.maxRadius = 0.3;

   // walls and ground
   this.groundY = -0.9;
   this.leftWallX = -1.0; 
   this.rightWallX = 1.0; 
   this.backWallZ = -1.0;
   this.frontWallZ = 1.0;

   this.spheres = [];
   this.sphereColors = [];
   this.sphereN = 0;
   
   // Add a sphere when clicking the canvas
   let canvas = document.getElementById('canvas');
   canvas.addEventListener('click', e => {
      if (this.sphereN >= NS) return;

      console.log('add sphere');

      const rect = canvas.getBoundingClientRect();

      let x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      let y = -(((e.clientY - rect.top) / rect.height) * 2 - 1);
      let r = this.minRadius + Math.random() * (this.maxRadius - this.minRadius);
      let z = this.backWallZ + r + Math.random() * (this.frontWallZ - this.backWallZ - 2*r );
 
      this.spheres.push({
         pos:[x, y, z, r], vel:[0, 0, 0]    // position(x,y,z,radius) and velocity(vx,vy,vz)
      });
      this.sphereColors.push( Math.random(), Math.random(), Math.random() );
      this.sphereN++;
   });

   this.update = viewPoint => {
      let time = Date.now()/1000 - startTime;
      setUniform('1f', 'uTime', time);
      setUniform('3fv', 'uViewPoint', viewPoint);

      let s = Math.sin(time * 2);
      let c = Math.cos(time * 2);

      let dt = 0.016; // 60fps

      // update sphere positions
      for (let s of this.spheres) {
         // add gravity
         s.vel[1] += this.gravity * dt;
         // update position
         s.pos[0] += s.vel[0] * dt;
         s.pos[1] += s.vel[1] * dt;
         s.pos[2] += s.vel[2] * dt;

         // sphere-sphere collision
         for (let s1 of this.spheres){
            if (s === s1) continue;
            let d = Math.sqrt( (s.pos[0]-s1.pos[0])*(s.pos[0]-s1.pos[0])
                        + (s.pos[1]-s1.pos[1])*(s.pos[1]-s1.pos[1])
                        + (s.pos[2]-s1.pos[2])*(s.pos[2]-s1.pos[2]) );
            if (d < s.pos[3] + s1.pos[3]) { // Hit
               let nx = (s1.pos[0]-s.pos[0]) / d;
               let ny = (s1.pos[1]-s.pos[1]) / d;
               let nz = (s1.pos[2]-s.pos[2]) / d;
               let p = 2 * (s.vel[0]*nx + s.vel[1]*ny + s.vel[2]*nz
                        - s1.vel[0]*nx - s1.vel[1]*ny - s1.vel[2]*nz) / 2;
               s.vel[0] -= p * nx;
               s.vel[1] -= p * ny;
               s.vel[2] -= p * nz;
               s1.vel[0] += p * nx;
               s1.vel[1] += p * ny;
               s1.vel[2] += p * nz;

               // separate overlapping spheres
               let overlap = 0.2 * (s.pos[3] + s1.pos[3] - d + 0.001);
               s.pos[0] -= overlap * nx;
               s.pos[1] -= overlap * ny;
               s.pos[2] -= overlap * nz;
               s1.pos[0] += overlap * nx;
               s1.pos[1] += overlap * ny;
               s1.pos[2] += overlap * nz;
            }
         }

         // walls and ground collision
         if (s.pos[1] < this.groundY + s.pos[3] ) { 
            s.pos[1] = this.groundY + s.pos[3];
            s.vel[1] = -s.vel[1] * this.bounce;
         }
         if (s.pos[0] < this.leftWallX + s.pos[3]) {
            s.pos[0] = this.leftWallX + s.pos[3];
            s.vel[0] = -s.vel[0] * this.bounce; 
         }
         if (s.pos[0] > this.rightWallX - s.pos[3]) {
            s.pos[0] = this.rightWallX - s.pos[3];
            s.vel[0] = -s.vel[0] * this.bounce; 
         }
         if (s.pos[2] < this.backWallZ + s.pos[3]) {
            s.pos[2] = this.backWallZ + s.pos[3];
            s.vel[2] = -s.vel[2] * this.bounce;
         }
         if (s.pos[2] > this.frontWallZ - s.pos[3]) {
            s.pos[2] = this.frontWallZ - s.pos[3];
            s.vel[2] = -s.vel[2] * this.bounce;
         }
      }

      
      this.LightDir = [ normalize([1,1,1]),
                        normalize([-1,-1,-.5]),
                        normalize([s,-1,c])
                     ].flat();             
      this.LightColor = [  .5,.8,1,
                           .4,.5,.2,
                           .4,.4,.2 
                        ];   

      setUniform('4fv', 'uS',
         this.spheres.map(s => s.pos).flat()
      );

      setUniform('3fv', 'uSC', this.sphereColors);

      setUniform('1i', 'uSN', this.sphereN);

      setUniform('3fv', 'uL', this.LightDir);

      setUniform('3fv', 'uLC', this.LightColor);

   }

}
gl_start(canvas, new Scene());
</script>

