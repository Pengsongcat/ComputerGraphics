<body bgcolor=black>
   <h1 style="color:#fff; text-align:center;">Drag the Cube</h1>
   <br>
   <center><canvas id=canvas width=800 height=800></canvas>
<script src=webgl.js></script>
<script>

// ADDING REACHING AND LOOKING

function Scene() {

let ball = Shape.sphereMesh(20,10);
let tube = Shape.tubeMesh(20);
let cube = Shape.cubeMesh();

this.vertexShader = Shader.defaultVertexShader;
this.fragmentShader = Shader.defaultFragmentShader;

autodraw = false;

let M = new Matrix();

let spin = 0;
mouse.drag = (x,y) => spin += x;

let draw = (mesh, matrix, color) => {
   let m = mxm(perspective(0,0,-.5),
           mxm(turnY(spin),
	   mxm(scale(.7),
               matrix ?? M.get())));
   setUniform('Matrix4fv', 'uMF', false, m);
   setUniform('Matrix4fv', 'uMI', false, inverse(m));
   setUniform('3fv', 'uColor', color ?? [1,1,1]);
   drawMesh(mesh);
   return this;
}

let Hip = [], Knee = [], Ankle = [];
let Shoulder = [], Elbow = [], Wrist = [];

let pos = m => m.slice(12,15);

let drawRod = (A,B,r) => {
   let D = subtract(B,A);
   draw(tube, mxm(move(mix(A,B,.5)),
              mxm(aim(D),
	          scale(r,r,norm(D)/2))));
}

// Spring
let springX = new Spring();
let springY = new Spring();
let forceX = 0, forceY = 0;
let dragX = 0, dragY = 0;
mouse.drag = (x,y) => {dragX += x; dragY += y};
mouse.up = () => {forceX = dragX; forceY = dragY};

let sHard = 0.5;

let sway = 1.0;
let legLen = 1.25;
let stride = legLen * 0.33;
let rate = 3.;
let time;

this.update = () => {
   time = Date.now() / 1000;

   // update Spring
   if (! mouse.isDown) {
      springX.setForce(forceX *= .9);
      springY.setForce(forceY *= .9);
      springX.update(0.03);
      springY.update(0.03);
      dragX = springX.getPosition();
      dragY = springY.getPosition();
   }

   let P = [sHard * dragX, sHard * dragY + 0.5, 0.7];
   // let P = [.1 * Math.cos(3 * time),.5 + .1 * Math.sin(3*time),.7];

   let grab = ease(Math.sin(rate * time) + .5);

   // body rotation
   M.push().turnY(Math.sin(time) * 0.1 * Math.PI );

   for (let i = 0 ; i < 2 ; i++) {
      let theta = rate * time + i * Math.PI;
      let c = Math.cos(theta) * .5;
      let s = Math.sin(theta) * .5 + .5;
      let theta2 = 2 * rate * time + i * Math.PI;
      let c2 = Math.cos(theta2) * .5;
      let s2 = Math.sin(theta2) * .5 + .5;
      let theta3 = 3 * rate * time + i * Math.PI;
      let c3 = Math.cos(theta3) * .5;
      let s3 = Math.sin(theta3) * .5 + .5;
      
      let sign = i == 0 ? -1 : 1;
      let hip, ankle;

      M.push();
         M.push().move(sign*.16 +.05*sign*c, 0.2 -.1*sign*c2 +.05*c3*sway,0.02 * c3);
            hip = M.get();
            M.push().move(
                  0.02 * sign - 0.1 *sign *c3,
                  -legLen + 0.05 -.1*c3,
                  // Math.max(-legLen-.1*c3,
                  //          -1.076*legLen*(1+.20*c3)),
                  -0);
               ankle = M.get();
            M.pop();
         M.pop();
      M.pop();

      Hip[i] = pos(hip);
      Ankle[i] = pos(ankle);
      Knee[i] = ik(Hip[i],.65,.65,Ankle[i],[0,4,1]);
  
      draw(ball, mxm(move(Hip[i]), scale(.05)));
      draw(ball, mxm(move(Knee[i]), scale(.05)));
      draw(ball, mxm(move(Ankle[i]), scale(.05)));

      drawRod(Hip[i], Knee[i], .03);
      drawRod(Knee[i], Ankle[i], .03);

      let shoulder, wrist;

      M.push();
         let S = [sign*(.2 + 0.1 * c), .8+ .15*c3*sway,0.4 *c];
         // let d = resize(subtract(P,S), .1*sign*grab);
         // S = add(S, [0, d[1], d[2]-d[0]]);
         M.push().move(S);
            shoulder = M.get();
            M.push().move(-sign * 0.8 * c,-.6 + 0.3 * c3, 0.29 + .05*c);
               wrist = M.get();
            M.pop();
         M.pop();
      M.pop();

      Shoulder[i] = pos(shoulder);
      Wrist[i] = pos(wrist);

      // if (i == 1) {
      //    Wrist[i] = mix(Wrist[i], P, grab);
      //    Wrist[i] = add(Wrist[i],
	   //              resize([1,0,0], .5*grab*(1-grab)));
      // }

      Elbow[i] = ik(Shoulder[i],.45,.45,Wrist[i], [0,-1,-1]);

      draw(ball, mxm(move(Shoulder[i]), scale(.05)));
      draw(ball, mxm(move(Elbow[i]), scale(.05)));
      draw(ball, mxm(move(Wrist[i]), scale(.05)));

      drawRod(Shoulder[i], Elbow[i], .03);
      drawRod(Elbow[i], Wrist[i], .03);
   }

   let Head = [-.13*Math.cos(rate*time),1.06+.1*Math.cos(2*rate*time),0.08 -.08*Math.cos(2*rate*time)];
   Head[0] += 0.3 * P[0];
   Head[1] += 0.05 * P[1];
   // let HeadFwd = mix([0,0,1],subtract(P,Head),.01+grab);
   let HeadFwd = subtract(P, Head);
   M.push().move(Head).aim(HeadFwd);
      draw(ball, mxm(M.get(), scale(.12,.14,.12)));
      draw(ball, mxm(M.get(),
                 mxm(move(-.05,0,.12),scale(.03))), [0,0,0]);
      draw(ball, mxm(M.get(),
                 mxm(move( .05,0,.12),scale(.03))), [0,0,0]);
   M.pop();

   M.pop();

   drawRod(Hip[0], Hip[1], .03);

   draw(cube, mxm(move(P), scale(.05)), [1,0,0]);
}

}

gl_start(canvas, new Scene());
</script>

