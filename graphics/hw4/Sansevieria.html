<body bgcolor="white">
<center><canvas id=canvas width=800 height=800></canvas>
<script src=webgl.js></script>
<script src=functions.js></script>
<script>

function Scene() {

let NL = 1;
let NGroup = 10;
let GroupSize = 3;

this.vertexShader = `\
#version 300 es
in  vec3 aPos;
out vec3 vPos;
void main() {
   gl_Position = vec4(aPos, 1.);
   vPos = aPos;
}`;

this.fragmentShader = `\
#version 300 es
precision highp float;

uniform float uTime;
uniform vec3 uViewPoint;

uniform mat4 uQ[`+NGroup*GroupSize+`];
// uniform vec3 uColor[`+NGroup+`];
uniform vec3 uAmbient[`+NGroup+`], uDiffuse[`+NGroup+`];
uniform vec4 uSpecular[`+NGroup+`];

uniform vec3 uL[`+NL+`], uLColor[`+NL+`];

in  vec3 vPos;
out vec4 fragColor;

vec3 rayEq(vec3 V, vec3 W, mat4 Q) {

   float A = Q[0].x, B = Q[1].x+Q[0].y, C = Q[2].x+Q[0].z, D = Q[3].x+Q[0].w,
                     E = Q[1].y       , F = Q[2].y+Q[1].z, G = Q[3].y+Q[1].w,
                                        H = Q[2].z       , I = Q[3].z+Q[2].w,
                                                           J = Q[3].w       ;

   float a = A * W.x * W.x +
             B * W.x * W.y +
             C * W.z * W.x +
             E * W.y * W.y +
             F * W.y * W.z +
             H * W.z * W.z ;

   float b = 2. * A * V.x * W.x +
                  B * (W.x * V.y + V.y * W.x) +
                  C * (V.z * W.x + V.x * W.z) +
                  D * W.x +
             2. * E * V.y * W.y +
                  F * (V.y * W.z + V.z * W.y) +
                  G * W.y +
             2. * H * V.z * W.z +
                  I * W.z;

   float c = A * V.x * V.x +
             B * V.x * V.y +
             C * V.z * V.x +
             D * V.x       +
             E * V.y * V.y +
             F * V.y * V.z +
             G * V.y       +
             H * V.z * V.z +
             I * V.z       +
             J;

   return vec3(a,b,c);
}

vec2 findRoots(vec3 eq) {
   float a = eq.x, b = eq.y, c = eq.z;
   vec2 t = vec2(-1.);
   float discr = b * b - 4. * a * c;
   if (discr >= 0.)
      t = vec2(-b - sqrt(discr), -b + sqrt(discr)) / (2. * a);
   return t;
}

vec3 normalQ(mat4 Q, vec3 P) {

   float A = Q[0].x, B = Q[1].x+Q[0].y, C = Q[2].x+Q[0].z, D = Q[3].x+Q[0].w,
                     E = Q[1].y       , F = Q[2].y+Q[1].z, G = Q[3].y+Q[1].w,
                                        H = Q[2].z       , I = Q[3].z+Q[2].w,
                                                           J = Q[3].w       ;

   return normalize(vec3(2. * A * P.x + C * P.z + B * P.y + D,
                         2. * E * P.y + F * P.z + B * P.x + G,
                         2. * H * P.z + F * P.y + C * P.x + I));
}

bool inShadow(vec3 P, vec3 L) {
   for (int g = 0 ; g < `+NGroup+` ; g++){
      vec2 tI = vec2(-1.,1000.);          // tI: the enter and exit t of group g
      for (int i = 0 ; i < `+GroupSize+` ; i++) {
         int q = g * `+GroupSize+` + i;
         vec2 tQ = findRoots(rayEq(P, L, uQ[q]));
         if (tQ.x > tI.x)
            tI.x = tQ.x;
         if (tQ.y < tI.y)
            tI.y = tQ.y;
      }
      if (tI.x > 0. && tI.x < tI.y) {
         return true;
      }
   }
   return false;
}

vec3 phong(vec3 N, vec3 L, vec3 W,
           vec3 diffuse, vec4 specular) {
   vec3 R = 2. * N * dot(N, L) - L;
   float highlight_dir = max(0., -dot(R, W));
   vec3 d = diffuse * max(0., dot(N, L)); 
   vec3 s = specular.rgb * pow(highlight_dir, specular.a);
   vec3 c = d + s;
   return c;
}

float fractal(vec3 P) {
   float f = 0., s = 1.;
   for (int i = 0 ; i < 5 ; i++) {
      f += noise(s * P) / s;
      s *= 2.;
      P = vec3(.866*P.x + .5*P.z, P.y + 100., -.5*P.x + .866*P.z);
   }
   return f;
}

float turbulence(vec3 P) {
   float f = 0., s = 1.;
   for (int i = 0 ; i < 5 ; i++) {
      f += abs(noise(s * P)) / s;
      s *= 2.;
      P = vec3(.866*P.x + .5*P.z, P.y + 100., -.5*P.x + .866*P.z);
   }
   return f;
}

vec3 sansevieria(vec3 pos, int seed) {
   float v = turbulence(pos);
   pos.y += .08 * fractal(vec3(30. * pos.x, pos.y, pos.z)) + .05 * fractal(vec3(100. * pos.x, pos.y, pos.z));
   pos.y += .2 * turbulence(3. * pos);

   float freq = 30. + 10. * fract(sin(float(seed) * 1234.567) * 7654.321);
   // freq = 38.;
   float pattern = 0.5 + 0.5 * sin(freq * pos.y + 10. * v);
   pattern = smoothstep(0.1, 0.8, pattern);

   vec3 g1 = vec3(0.04, 0.09, 0.01);
   vec3 g2 = vec3(0.7, 0.8, 0.2);
   vec3 c = mix(g1, g2, pattern);
   c = mix(c, g2, 0.4 * fractal(7.0 * pos));
   c += 0.28 * fractal(100.0 * pos);
   
   return c;
}

vec3 soil(vec3 pos) {

    float s = abs(sqrt(2. * turbulence(5. * pos)));

    vec3 darkSoil = vec3(0.23, 0.07, 0.01); 
    vec3 redSoil  = vec3(0.16, 0.04, 0.01);
    vec3 c = mix(darkSoil, redSoil, s);
    c = mix(c, vec3(0.07, 0.02, 0.0), 1.2 * noise(40. * pos));
    c += darkSoil * 0.7 * noise(120. * pos);

    return c;
}

vec3 marble(vec3 pos) {
   float v = turbulence(pos);
   float s = sqrt(.5 + .5 * sin(10. * pos.z + 30. * v));
   return vec3(s,s*s,s*s*s);
}

vec3 wood(vec3 pos) {
   pos.y += .5 * turbulence(.7*pos);
   vec3 c = vec3(0.9,.6,.5) *
            mix(1.5, .1,
	        .5 + .25 * turbulence(vec3(.5,40.,40.) * pos+2.*sin(pos))
                   + .25 * turbulence(vec3(40.,40.,.5) * pos+2.*sin(pos)));
   c *= .2 + .8 * pow(abs(sin(10. * pos.y)), .4);
   return c;
}

void main() {
   fragColor = vec4(0.);

   vec3 V = uViewPoint;
   vec3 W = normalize(vPos-V);

   float nearestT = 1000.;
   vec3 finalColor = vec3(0.);

   for (int g = 0 ; g < `+NGroup+` ; g++){
      vec2 tI = vec2(-1.,1000.);          // tI: the enter and exit t of group g
      vec3 nearestNormal = vec3(0.);      // the nearestNormal at tI.x
      for (int i = 0 ; i < `+GroupSize+` ; i++) {
         int q = g * `+GroupSize+` + i;
         vec2 tQ = findRoots(rayEq(V, W, uQ[q]));
         if (tQ.x > tI.x) {
            vec3 N = normalQ(uQ[q] , V + tQ.x * W);
            nearestNormal = N;
            tI.x = tQ.x;
         }
         if (tQ.y < tI.y)
            tI.y = tQ.y;
      }
      // if the nearest intersection of group g is the nearest within all groups so far, shade it
      if (tI.x > 0. && tI.x < tI.y && tI.x < nearestT) {
         nearestT = tI.x;
         vec3 shade = uAmbient[g];
         vec3 P = V + nearestT * W;
         for (int l = 0 ; l < `+NL+` ; l++){ 
            bool shadow = inShadow(P, uL[l]);
            if (! shadow)
               shade += uLColor[l] * phong(nearestNormal, uL[l], W, uDiffuse[g], uSpecular[g]);
         }
         if (g == 0){
            finalColor = shade * wood(P);
         }
         else if (g == 1){
            finalColor = shade * marble(P);
         }
         else if (g == 2){
            finalColor = shade * soil(P);    
         }
         else{
            finalColor = shade * sansevieria(P, g);
         }
      }
   }
   
   if (finalColor != vec3(0.))
      fragColor = vec4(sqrt(finalColor), 1.);
   else
      fragColor = vec4(0.);

}`;

let mxm = (a,b) => {
   let m = [];
   for (let c = 0 ; c < 16 ; c += 4)
   for (let r = 0 ; r < 4 ; r++)
      m.push( a[r]*b[c] + a[r+4]*b[c+1] + a[r+8]*b[c+2] + a[r+12]*b[c+3] );
   return m;
}

let transpose = m => [ m[0],m[4],m[ 8],m[12],
                       m[1],m[5],m[ 9],m[13],
                       m[2],m[6],m[10],m[14],
                       m[3],m[7],m[11],m[15] ];

let inverse = src => {
   let dst = [], det = 0, cofactor = (c, r) => {
      let s = (i, j) => src[c+i & 3 | (r+j & 3) << 2];
      return (c+r & 1 ? -1 : 1) * ( (s(1,1)*(s(2,2)*s(3,3)-s(3,2)*s(2,3)))
                                  - (s(2,1)*(s(1,2)*s(3,3)-s(3,2)*s(1,3)))
                                  + (s(3,1)*(s(1,2)*s(2,3)-s(2,2)*s(1,3))) );
   }
   for (let n = 0 ; n < 16 ; n++) dst.push(cofactor(n >> 2, n & 3));
   for (let n = 0 ; n <  4 ; n++) det += src[n] * dst[n << 2];
   for (let n = 0 ; n < 16 ; n++) dst[n] /= det;
   return dst;
}

let qxm = (Q,M) => {
   let MI = inverse(M);
   return mxm(transpose(MI), mxm(Q, MI));
}

let normalize = v => {
      let s = Math.sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]);
      return [ v[0]/s, v[1]/s, v[2]/s ];
   }

let startTime = Date.now()/1000;

let deg2rad = deg => deg * Math.PI / 180;

this.update = viewPoint => {
   let time = Date.now()/1000 - startTime;
   setUniform('1f', 'uTime', time);
   setUniform('3fv', 'uViewPoint', viewPoint);

   setUniform('3fv', 'uL', [  // normalize([0.5,1,0.5]),
                              normalize([Math.sin(time / 2) * 2, 2, Math.cos(time / 2) * 2]),
                           ].flat());
   setUniform('3fv', 'uLColor', [   .4,.6,0.2,
                                    .4,.5,.2,
                                 ]);

   let geos = [   
                  [ parabY, space, space ],     // ground
                  [ coneY, slabY, space ],      // pot
                  [ sphere, space, space ],     // soil
                  [ sphere, space, space ],     // leaves
                  [ sphere, space, space ],
                  [ sphere, space, space ],
                  [ sphere, space, space ],
                  [ sphere, space, space ]
               ];
   let transforms = [
      [ mxm(move(0., -0.5, 0), mxm(turnX(deg2rad(0.1)), scale(16.)))],
      [ mxm(scale(0.3, 1.2, 0.3), move(0., -1.2, 1.8))],
      [ mxm(scale(0.29, 0.05, 0.29), move(0., -5.1, 1.8))],
      [ mxm(move(.11, 0.2, 0.7), mxm(turnY(deg2rad(-30)), scale(0.02, .5, .07)))],
      [ mxm(move(.03, 0.28, 0.45), mxm(turnY(deg2rad(-20)), scale(0.02, .6, .07)))],
      [ mxm(move(.2, 0.0, 0.6), mxm(turnY(deg2rad(20)), scale(0.02, .5, .06)))],
      [ mxm(move(-.09, 0.2, 0.7), mxm(turnY(deg2rad(10)), scale(0.02, .5, .08)))],
      [ mxm(move(-.2, 0.23, 0.6), mxm(turnY(deg2rad(50)), scale(0.02, .6, .07)))]
    ];
   let qArray = new Float32Array(
   geos.flatMap((geoGroup, g) =>
      geoGroup.map((geo, i) => {
         let t = Array.isArray(transforms[g])
                   ? (transforms[g][i] ?? transforms[g][0] ?? identity)
                   : (transforms[g] ?? identity);
         return qxm(geo, t);
      })
      ).flat()
   );
   setUniform('Matrix4fv', 'uQ', false, qArray);

   setUniform('3fv', 'uAmbient', [ 
                                 .5,.5, .6,
                                 .09,.08, .09,
                                 .02,.01, .06,
                                 .04,.08, .02,
                                 .05,.08, .02,
                                 .07,.08, .04,
                                 .03,.08, .02,
                                 .06,.08, .03,
                                 ]);
   setUniform('3fv', 'uDiffuse', [ 0.9,.7, 0.7
                                 , .6,.4, .9
                                 , .8,.5, .4
                                 , .5,0.6, .4
                                 , .8, 0.8, .1
                                 , .5, 0.9, .9
                                 , .5,0.4, .2
                                 , .2,0.3, .2
                                 ]);
   setUniform('4fv', 'uSpecular', [.7,.7, .9, 4
                                 , .9,.4, .1, 20
                                 , .1,.1, .01, 5
                                 , .8,.1, .9, 5
                                 , .8,.1, .9, 5
                                 , .8,.1, .9, 5
                                 , .8,.1, .9, 5
                                 , .8,.1, .9, 5
                                    ]);
   
}

}


gl_start(canvas, new Scene());
</script>
