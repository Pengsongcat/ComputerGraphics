<body bgcolor=black>
<center><canvas id=canvas width=800 height=800></canvas>
<script src=webgl.js></script>
<script>

// WOOD
function Scene() {

this.vertexShader = `\
#version 300 es
in  vec3 aPos;
out vec3 vPos;
void main() {
   gl_Position = vec4(aPos, 1.);
   vPos = aPos;
}`;

this.fragmentShader = `\
#version 300 es
precision highp float;
uniform float uTime;
uniform vec3 uViewPoint;
in  vec3 vPos;
out vec4 fragColor;

float fractal(vec3 P) {
   float f = 0., s = 1.;
   for (int i = 0 ; i < 9 ; i++) {
      f += noise(s * P) / s;
      s *= 2.;
      P = vec3(.866*P.x + .5*P.z, P.y + 100., -.5*P.x + .866*P.z);
   }
   return f;
}

float turbulence(vec3 P) {
   float f = 0., s = 1.;
   for (int i = 0 ; i < 9 ; i++) {
      f += abs(noise(s * P)) / s;
      s *= 2.;
      P = vec3(.866*P.x + .5*P.z, P.y + 100., -.5*P.x + .866*P.z);
   }
   return f;
}

vec3 marble(vec3 pos) {
   float v = turbulence(pos);
   float s = sqrt(.5 + .5 * sin(20. * pos.y + 8. * v));
   return vec3(.8,.7,.5) * vec3(s,s*s,s*s*s);
}

vec3 wood(vec3 pos) {
   pos.y += .5 * turbulence(.7*pos);
   vec3 c = vec3(1.,.42,.15) *
            mix(1.5, .1,
	        .5 + .25 * turbulence(vec3(.5,40.,40.) * pos+2.*sin(pos))
                   + .25 * turbulence(vec3(40.,40.,.5) * pos+2.*sin(pos)));
   c *= .2 + .8 * pow(abs(sin(10. * pos.y)), .4);
   return c;
}

vec3 sansevieria(vec3 pos) {
   float v = turbulence(pos);
   pos.y += .08 * fractal(vec3(30. * pos.x, pos.y, pos.z)) + .05 * fractal(vec3(100. * pos.x, pos.y, pos.z));
   pos.y += .2 * turbulence(3. * pos);

   float pattern = 0.5 + 0.5 * sin(38. * pos.y + 10. * v);
   pattern = smoothstep(0.1, 0.8, pattern);

   vec3 g1 = vec3(0.04, 0.09, 0.01);
   vec3 g2 = vec3(0.7, 0.8, 0.2);
   vec3 c = mix(g1, g2, pattern);
   c = mix(c, g2, 0.4 * fractal(7.0 * pos));
   c += 0.28 * fractal(100.0 * pos);
   
   return c;
}

vec3 soil(vec3 pos) {

    float s = abs(sqrt(2. * turbulence(5. * pos)));

    vec3 darkSoil = vec3(0.23, 0.07, 0.01); 
    vec3 redSoil  = vec3(0.16, 0.04, 0.01);
    vec3 c = mix(darkSoil, redSoil, s);
    c = mix(c, vec3(0.07, 0.02, 0.0), 1.2 * noise(40. * pos));
    c += darkSoil * 0.7 * noise(120. * pos);

    return c;
}

vec3 oilwater(vec3 pos) {
   pos.y += .5 * turbulence(5. * pos);
   float t = .5 + .5 * turbulence(vec3(.5,20.,.5) * pos+2.*sin(pos));        
   vec3 c = vec3(1.,.42,.15) * mix(1.5, .1, t);
   // c *= .2 + .8 * pow(abs(sin(10. * pos.y)), .4);
   return c;
}

void main() {
   vec4 F = vec4(0.);
   float x = 2. * vPos.x;
   float y = 2. * vPos.y;
   float rr = x*x + y*y; 
   if (rr < 1.) {
      float z = sqrt(1. - rr);
      float c = .1 + .5 * max(0., x+y+z);
      vec3 P = vec3(vPos.x, vPos.y,z);
      P = vPos;
      F = vec4(c * soil(P),1.);
   }
   fragColor = vec4(sqrt(F.rgb), F.a);
}`;

let startTime = Date.now()/1000;

this.update = viewPoint => {
   let time = Date.now()/1000 - startTime;
   setUniform('1f', 'uTime', time);
   setUniform('3fv', 'uViewPoint', viewPoint);
}

}

gl_start(canvas, new Scene());
</script>


