<body bgcolor=black>
<center><canvas id=canvas width=800 height=800></canvas>
<script src=webgl.js></script>
<script>

function Scene() {

this.vertexShader = `#version 300 es
in  vec3 aPos;
out vec3 vPos;
void main() {
   gl_Position = vec4(aPos, 1.);
   vPos = aPos;
}`;

this.fragmentShader = `#version 300 es
precision highp float;
uniform float uTime;
in  vec3 vPos;
out vec4 fragColor;

void main() {
   fragColor = vec4(0.);
   vec3 ambient = vec3(.2,.1,.05);
   vec3 sky_color = vec3(.5,.85,1.5);

   float zMax = -1000.; 
   vec3 light_direction = normalize(vec3(sin(2. * uTime), sin(200. + 2. * uTime), .8));   // A moving light direction
   float light_intensity = 0.5 + 0.3 * sin(1.5 * uTime);

   for (int i = 1 ; i < 61 ; i++) {
      float fi = float(i);
      float speed = (.6 + .2 * sin(fi)) * sign(sin(16.34 * fi));
      vec3 color = vec3(.5 + .2 * sin(fi),
                        .5 + .5 * sin(fi),
                        .5 + .5 * sin(fi));
      float vx = vPos.x;
      float vy = vPos.y;
      //vx += .2 * sin(5. * vy + 3. * uTime);
      //vy += .2 * sin(5. * vx + 1. * uTime);
      
      // position of the "i-th" sphere
      float x = 8. * vx + 6. * sin(20.5 * fi + 100.3 + speed * uTime);
      float y = 8. * vy + 6. * sin(10.3 * fi + 200.6 + speed * uTime);
      float z = 8. * vy + 6. * cos(11.6 * fi + 100.6 + speed * uTime);
      float radius = .1 + .1 * z;

      float rr = radius*radius - x*x - y*y;
      z += rr / (8.*8.); 

      if (rr > 0. && z > zMax) {
         zMax = z;
         float z = sqrt(rr);
         vec3 p = vec3(x, y, z);
         float D = dot(p, light_direction);
	      D = light_intensity * max(0., D) / z;
         vec3 diffuse = D * sky_color;
         fragColor = vec4(sqrt(color * (ambient + diffuse)), 1.);
      }
   }
}`;

let startTime = Date.now() / 1000;

this.update = () => {
   setUniform('1f', 'uTime', Date.now() / 1000 - startTime);
}

}

gl_start(canvas, new Scene());
</script>
