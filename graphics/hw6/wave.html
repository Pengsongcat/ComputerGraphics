<body bgcolor=black>
<center>
<div style="color: white; margin-bottom: 10px;">
    <div style="margin-bottom: 5px;">
        Speed: <input type="range" id="speedSlider" min="1.0" max="4.0" step="0.1" value="2.5" style="width: 200px">
    </div>
    <div>
        Color: <input type="range" id="blueSlider" min="0.9" max="1.0" step="0.01" value="0.95" style="width: 200px">
    </div>
</div>
<canvas id=canvas width=800 height=800></canvas>
<script src=webgl.js></script>
<script>

function Scene() {

// GENERIC PARAMETRIC SURFACE

let parametric = (f,nu,nv,other) => {
   let V = [];
   for (let j = 0 ; j < nv ; j++) {
      for (let i = 0 ; i <= nu ; i++) {
         V.push(f(i/nu,j/nv,other));
         V.push(f(i/nu,(j+1)/nv,other));
      }
      V.push(f(1,(j+1)/nv,other));
      V.push(f(0,(j+1)/nv,other));
   }
   return V.flat();
}

// BUILD A BEZIER PATCH AS A PARAMETRIC SURFACE

let bezierPatch = (nu,nv,patch) => parametric((u,v,patch)=>{

   // EXTRACT THE BEZIER PATCH DATA

   let BX = patch[0], BY = patch[1], BZ = patch[2];

   // MATH TO EVALUATE A BEZIER SPLINE

   let M = [ [-1,3,-3,1],[3,-6,3,0],[-3,3,0,0],[1,0,0,0] ];
   let T = (a,t) => a[0]*t*t*t + a[1]*t*t + a[2]*t + a[3];
   let Vi = (V,i,t) => V[i] * T(M[i],t);
   let C = (V,t) => Vi(V,0,t)+Vi(V,1,t)+Vi(V,2,t)+Vi(V,3,t);

   // MATH TO FIND THE POSITION OF ONE POINT ON THE PATCH

   let bezier = (u,v) => {
      let Xu = [], Yu = [], Zu = [];
      for (let i = 0 ; i < 16 ; i += 4) {
         Xu.push(C(BX.slice(i,i+4), u));
         Yu.push(C(BY.slice(i,i+4), u));
         Zu.push(C(BZ.slice(i,i+4), u));
      }
      return [ C(Xu,v), C(Yu,v), C(Zu,v) ];
   }

   // COMPUTE AND RETURN THE POINT AND NORMAL ON THE PATCH

   let P = bezier(u,v),
       N = normalize(cross(subtract(bezier(u+.001,v),P),
                           subtract(bezier(u,v+.001),P)));
   return [ P[0],P[1],P[2], N[0],N[1],N[2] ];

},nu,nv,patch);

// GLSL SHADERS

this.vertexShader = `\
#version 300 es
uniform mat4 uMF, uMI;
in  vec3 aPos, aNor;
out vec3 vPos, vNor;
void main() {
   vec4 pos = uMF * vec4(aPos, 1.);
   vec4 nor = vec4(aNor, 0.) * uMI;
   gl_Position = pos * vec4(1.,1.,-.1,1.);
   vPos = pos.xyz;
   vNor = nor.xyz;
}`;

this.fragmentShader = `\
#version 300 es
precision highp float;
in  vec3 vPos, vNor;
out vec4 fragColor;
uniform float uTime;
uniform float uBlue;
uniform float uSpeed;

float turbulence(vec3 P) {
   float f = 0., s = 1.;
   for (int i = 0 ; i < 9 ; i++) {
      f += abs(noise(s * P)) / s;
      s *= 2.;
      P = vec3(.866*P.x + .5*P.z, P.y + 100., -.5*P.x + .866*P.z);
   }
   return f;
}

vec3 oilwater(vec3 pos) {
   pos.y += .5 * turbulence(uSpeed * uTime * .5 + 6. * pos);
   float t = .5 + .5 * turbulence(vec3(.5,20.,.5) * pos+2.*sin(pos));        
   vec3 c = vec3(0.8,.8,.8) * mix(1.5, .1, t);
   c *= 1.+ .6 * pow(abs(sin(10. * pos.y)), 10.);
   return c;
}

void main() {
   vec3 nor = normalize(vNor);

   vec3 texture = oilwater(vPos);

   float shade = .1 + max(0., dot(vec3(.9) * texture,nor));
   vec3 c = shade * vec3(0.2, 0.9, uBlue);
   fragColor = vec4(c, 1.);
}`;

let speed = 2.5;
let blue = 0.8;
const setupSliders = () => {
    const speedSlider = document.getElementById('speedSlider');
    const blueSlider = document.getElementById('blueSlider');
    const speedValue = document.getElementById('speedValue');
    const blueValue = document.getElementById('blueValue');

    speedSlider.oninput = () => {
        speed = parseFloat(speedSlider.value);
        speedValue.textContent = speed.toFixed(1);
    };

    blueSlider.oninput = () => {
        blue = parseFloat(blueSlider.value);
        blueValue.textContent = blue.toFixed(2);
    };
};
setTimeout(setupSliders, 0);

let startTime = Date.now()/1000;

this.update = () => {
   let time = Date.now() / 1000 - startTime;

   _.X = [ -.80,-.20, .20, .80 ,
         -.80,-.20, .20, .80 ,
         -.80,-.20, .20, .80 ,
         -.80,-.20, .20, .80 ];

   _.Y = [ -.80,-.80,-.80,-.80 ,
         -.20,-.20,-.20,-.20 ,
            .20, .20, .20, .20 ,
            .80, .80, .80, .80 ];

   _.Z = [ -.10 * Math.cos(time*speed), -.20 * Math.sin(time*speed),.20 * Math.cos(time*speed),-.10 * Math.sin(time*speed),
            -.20 * Math.sin(time*speed), .40 * Math.cos(time*speed), .40 * Math.sin(time*speed),-.20 * Math.cos(time*speed) ,
            -.20 * Math.cos(time*speed), .40 * Math.sin(time*speed), .40 * Math.cos(time*speed),-.20 * Math.sin(time*speed),
            -.10 * Math.sin(time*speed),-.20 * Math.cos(time*speed),-.20 * Math.sin(time*speed),-.10 * Math.cos(time*speed) ];

   mesh = {
      triangle_strip: true,
      data: new Float32Array(bezierPatch(10,10,[_.X,_.Y,_.Z])),
   };

   setUniform('1f', 'uTime', time);
   setUniform('1f', 'uSpeed', speed);
   setUniform('1f', 'uBlue', blue);

   let m = mxm(perspective(0,0,-.1),
           mxm(turnY(_.theta??0),turnX(_.phi??-Math.PI/2.5)));
   setUniform('Matrix4fv', 'uMF', false, m);
   setUniform('Matrix4fv', 'uMI', false, inverse(m));
}

}
gl_start(canvas, new Scene());
</script>
